API reference guide
========================

``LossModel``
---------------

.. autoclass:: lossmodel.LossModel
   :members:
   :inherited-members:


(Re)insurance pricing
~~~~~~~~~~~~~~~~~~~~~~~~~~~

GEMAct pricing model is based on the collective risk theory.

.. math:: \widetilde{X}=\sum_{i=1}^{\widetilde{N}} \widetilde{{Z_i}}
   :label: crm

Denote the pure reinsurance premium as :math:`P= \mathbb{E}\left( X \right)`

In order to price our (re)insurance contracts we model the company aggregate claim cost under the following assumptions.

* :math:`\widetilde{X} \sim g(X)` and :math:`\widetilde{Z_i} \sim f(Z)`
*  Given :math:`\widetilde{N}=n`,  the severity :math:`\widetilde{Z_1},\ldots,\widetilde{Z_n}` is i.i.d and does not depend on :math:`n`.
* :math:`\widetilde{N}` does not depend on :math:`\widetilde{Z_1},\ldots,\widetilde{Z_n}` in any way.

Pricing models
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following table gives the correspondence between the ``LossModel`` class attributes and our pricing model as presented below.

+------------------------+-----------------------------------------+
| Pricing model notation | Parametrization in ``LossModel``        |
|                        |                                         |
+========================+=========================================+
|:math:`d`               |      deductible                         |
+------------------------+-----------------------------------------+
| :math:`u`              | deductible+cover                        |
+------------------------+-----------------------------------------+
| :math:`L`              | aggr_n_deductible * deductible          |
+------------------------+-----------------------------------------+
| :math:`K`              |       n_reinst                          |
+------------------------+-----------------------------------------+
|:math:`c_{k}`           |      reinst_loading                     |
+------------------------+-----------------------------------------+
| :math:`\alpha`         | alpha_qs                                |
+------------------------+-----------------------------------------+

Assume: 

.. math:: X^{\prime}=\min (\max (0, X-L), (K+1) \cdot u)
   :label: crmRE

Given :math:`\widetilde{X}=\sum_{i=1}^{\widetilde{N}} \widetilde{Y}_{i}`, where :math:`\widetilde{Y}_i` is defined in equation :eq:`crmRE`.

.. math:: \widetilde{Y}_{i}=\min \left(\max \left(0, \widetilde{Z}_{i}-d\right), u\right)
   :label: XLpremium

Equation :eq:`XLpremium` shows the reinsurance premium for excess of loss treaties. It is possible to obtain a plain-vanilla XL with :math:`L=0`, :math:`K=+\infty` and :math:`c=0`.

.. math:: P=\frac{D_{L K}}{1+\frac{1}{m} \sum_{k=1}^{K} c_{k} d_{L, k-1}}
   :label: reinstatementsLayer

GEMAct pricing model is based on  :cite:t:`b:kp` and  :cite:t:`sundt`. 

Refer again to :cite:t:`b:kp` for the recursive formula to compute the collective risk model and to :cite:t:`embrechts` for the Fast Fourier transform to approximate the Discrete Fourier Transform of the collective risk model.

Example
^^^^^^^^^^^^^^^^^^^^^^^^^^

``LossModel`` can be used to price reinsurance contracts.

An example of pricing with reinstatements::

   from gemact import LossModel
   lossm=gemact.LossModel(aggr_loss_dist_method='fft',
             fq_par={'mu':.5},
             fq_dist= 'poisson',
             sev_par={'loc':0,
                      'scale': 83,
                      'c': 0.83},
             sev_dist='genpareto',
             sev_discr_method='localmoments',
             n_sev_discr_nodes = int(10000),
             sev_discr_step = .01,
             n_aggr_dist_nodes = int(100000),
             deductible=0,
             aggr_n_deductible=0,
             reinst_loading=1,
             n_reinst=1)

   lossm.pricing()


``LossModel`` can be used to model the aggregate cost of claims::

   
      from gemact LossModel
      lm_fft= LossModel(aggr_loss_dist_method='fft',
                 fq_par = fq_par,
                 fq_dist = fq_dist,
                 sev_par = sev_par,
                 sev_dist = sev_dist,
                 n_sev_discr_nodes = int(1000),
                 sev_discr_step = 1,
                 n_aggr_dist_nodes = int(10000))

      print('FFT',lm_fft.aggr_loss_mean())
      #4.9999999846531935

Severity discretization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to pass from a continuous distribution to an arithmetic distribution, it is important to preserve the distribution properties either locally or globally. Given a span :math:`h` and :math:`M` the last available point, in :cite:t:`b:kp` there are two available solutions.

**Method of mass dispersal**

.. math:: f_{0}=\operatorname{Pr}\left(\widetilde{Y}<\frac{h}{2}\right)=F_{\widetilde{Y}}\left(\frac{h}{2}-0\right)
   :label: md1

.. math:: f_{j}=F_{\widetilde{Y}}\left(j h+\frac{h}{2}-0\right)-F_{\widetilde{Y}}\left(j h-\frac{h}{2}-0\right), \quad j=1,2, \ldots, M-1
   :label: md2


.. math:: f_{M}=1-F_{X}[(M-0.5) h-0]
   :label: md3

**Method of local moments matching**

The following approach is applied to preserve the global mean of the distribution.

.. math:: f_0 = m^0_0
   :label: lm1

.. math:: f_j = m^{j}_0+ m^{j-1}_1 , \quad j=0,1, \ldots, M
   :label: lm2

.. math:: \sum_{j=0}^{1}\left(x_{k}+j h\right)^{r} m_{j}^{k}=\int_{x_{k}-0}^{x_{k}+ h-0} x^{r} d F_{X}(x), \quad r=0,1
   :label: lm3

.. math:: m_{j}^{k}=\int_{x_{k}-0}^{x_{k}+p h-0} \prod_{i \neq j} \frac{x-x_{k}-i h}{(j-i) h} d F_{X}(x), \quad j=0,1
   :label: lm4


Example
^^^^^^^^^^^^^^^^^^^^^^^^^^

A simple code implementation of severity discretization::

   import numpy as np

    lossm_md=gemact.LossModel(aggr_loss_dist_method='fft',
                 fq_par={'mu':.5},
                 fq_dist= 'poisson',
                 sev_par={'loc':0,'scale': 83, 'c': 0.83},
                 sev_dist='genpareto',
                 cover=100,
                 sev_discr_method='massdispersal',
                 n_sev_discr_nodes = int(10000),
                 sev_discr_step = .01,
                 n_aggr_dist_nodes = int(100000))

    lossm_lm=gemact.LossModel(aggr_loss_dist_method='fft',
                 fq_par={'mu':.5},
                 fq_dist= 'poisson',
                 sev_par={'loc':0,'scale': 83, 'c': 0.83},
                 sev_dist='genpareto',
                 cover=100,
                 sev_discr_method='localmoments',
                 n_sev_discr_nodes = int(10000),
                 sev_discr_step = .01,
                 n_aggr_dist_nodes = int(100000))


    massD=lossm_md.severity_discretization()
    localM=lossm_lm.severity_discretization()

    meanMD = np.sum(massD['sev_nodes']*massD['fj'])
    meanLM = np.sum(localM['sev_nodes']*localM['fj'])

    print('Mean (mass dispersal): ',meanMD)
    print('Mean (local moments): ',meanLM)
    #Mean (mass dispersal):  64.61227417939517
    #Mean (local moments):  64.61227421887484

``LossReserve``
------------------

.. automodule:: lossreserve
   :members:


Claims reserving 
~~~~~~~~~~~~~~~~~~~~~~~~~~~

GEMAct provides a software implementation of average cost methods for claims reserving based on the collective risk model framework. 

The methods implemented in GEMAct are the Fisher-Lange in :cite:t:`fisher99` the collective risk model for claims reserving in :cite:t:`ricotta16`.

GEMAct allows for tail estimates and assumes the triangular inputs to be provided as a ``numpy.ndarray`` with two equal dimensions ``(I,J)``, where ``I=J``.

The aim of average cost methods is to model incremental payments as in equation :eq:`acmethods`.

.. math:: P_{i,j}=n_{i,j} \cdot m_{i,j}
   :label: acmethods

where :math:`n_{i,j}` is the number of payments in the cell :math:`i,j` and :math:`m_{i,j}` is the average cost in the cell :math:`i,j`.

Example
^^^^^^^^^^^^^^^^^^^^^^^^^^

It is possible to use the module ``gemdata`` to test GEMAct average cost methods::

   ip_= gemact.gemdata.IPtriangle 
   in_= gemact.gemdata.in_triangle 
   cp_= gemact.gemdata.cased_amount_triangle 
   cn_= gemact.gemdata.cased_number_triangle 
   reported_= gemact.gemdata.reported_ 
   infl_= gemact.gemdata.claims_inflation 
   rm_='fisherlange' 
   tail_=True 

An example of Fisher-Lange implementation::

    lr = gemact.LossReserve(tail=tail_,
               incremental_payments=ip_,
               cased_payments=cp_,
               cased_number=cn_,
               reported_claims=reported_,
               incurred_number=in_,
               reserving_method=rm_,
               claims_inflation=infl_)


An example of CRM implementation. Observe the CRM for reserving requires additional parameters::

    lr = gemact.LossReserve(tail=tail_,
                   incremental_payments=ip_,
                   cased_payments=cp_,
                   cased_number=cn_,
                   reported_claims=reported_,
                   incurred_number=in_,
                   ntr_sim=int(1000),
                   reserving_method="crm",
                   mixingfpar={'a':1/.08**2,'scale':.08**2},
                   mixingspar={'a':1/.08**2,'scale':.08**2},
                   claims_inflation=infl_)

``LossAggregation``
---------------------

.. autoclass:: lossaggregation.LossAggregation
   :members: None

Risks aggregation
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. math:: P\left[ X_1 +\ldots +X_d \right] \approx P_n(s)
   :label: pty

The probability in equation :eq:`pty` can be approximated iteratively via the AEP algorithm, which is implemented for the first time in the GEMAct package, under the following assumptions:

Assuming:

* :math:`𝑋=(X_i, \ldots, X_d)` vector of strictly positive random components.

* The joint c.d.f. :math:`H(x_1,…,x_d )=P\left[ X_1 +\ldots +X_d \right]` is known or it can be computed numerically.

Refer to :cite:t:`arbenz11` for an extensive explanation on the AEP algorithm.
It is possible to use a MC simulation for comparison.

Example
^^^^^^^^^^^^^^^^^^^^^^^^^^

Example code under a clayton assumption::

   la=gemact.LossAggregation(
                   margins=['genpareto',
                            'genpareto'],
                   margins_pars=[
                       {'loc':0,
                        'scale':1/.9,
                        'c':1/.9},
                        {'loc':0,
                          'scale':1/1.8,
                          'c':1/1.8}
                          ],
                   copula='clayton',
                   copula_par={'par':1.2,
                               'dim':2})

   print('cdf via AEP algorithm: \n',la.cdf(1,
                                         n_iter=7,
                                         method='aep'))

   print('cdf via MC: \n',la.cdf(1,
                                 method='mc'))




The ``distributions`` module
------------------------------------

``Poisson``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Poisson
   :members:


Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.poisson.html>`_, see :cite:t:`scipy`.



.. math:: f(k)=\exp (-\mu) \frac{\mu^{k}}{k !}
   :label: poisson

Given :math:`\mu \geq 0` and :math:`k \geq 0`.

Example code on the usage of the Poisson class::

    from gemact import distributions
    import numpy as np

    mu=4
    dist=distributions.Poisson(mu=mu)
    seq=np.arange(0,20)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Poisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~Poisson(mu=4)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~ Poisson(mu=4)')

.. image:: images/pmfPois.png
  :width: 400

.. image:: images/cdfPois.png
  :width: 400

``Binom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Binom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^


For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binom.html>`_, see :cite:t:`scipy`.

.. math:: f(k)=\left(
   \begin{array}{l}
      n \\
      k
   \end{array} \right) p^{k}(1-p)^{n-k}
   :label: binomial

for :math:`k \in\{0,1, \ldots, n\}, 0 \leq p \leq 1`

Example code on the usage of the Binom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=0.5
    dist=distributions.Binom(n=n,p=p)
    seq=np.arange(0,20)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Poisson::

    import matplotlib.pyplot as plt
    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~Binom(n=10,p=0.5)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~Binom(n=10,p=0.5)')

.. image:: images/pmfBinom.png
  :width: 400

.. image:: images/cdfBinom.png
  :width: 400

``Geom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Geom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.geom.html>`_, see :cite:t:`scipy`..

.. math:: f(k)=(1-p)^{k-1} p
   :label: geom

for :math:`k \geq 1,0<p \leq 1`

Example code on the usage of the Geom class::

    from gemact import distributions
    import numpy as np

    p=0.8
    dist=distributions.Geom(p=p)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Geom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~Geom(p=0.8)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~Geom(p=0.8)')

.. image:: images/pmfGeom.png
  :width: 400

.. image:: images/cdfGeom.png
  :width: 400

``NegBinom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.NegBinom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.nbinom.html>`_, see :cite:t:`scipy`.

.. math:: f(k)=\left(\begin{array}{c}
      k+n-1 \\
      n-1
   \end{array}\right) p^{n}(1-p)^{k}
   :label: geom

for :math:`k \geq 0,0<p \leq 1`

Example code on the usage of the NegBinom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=.5
    dist=distributions.Nbinom(n=n,p=p)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a NBinom::

    import matplotlib.pyplot as plt
    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~NBinom(n=10,p=0.8)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~NBinom(n=10,p=0.8)')

.. image:: images/pmfNBinom.png
  :width: 400

.. image:: images/cdfNBinom.png
  :width: 400

``ZTpoisson``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZTPoisson
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a Poisson distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated poisson is defined in equation :eq:`ztpois`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztpois


Example code on the usage of the ZTPoisson class::

    from gemact import distributions
    import numpy as np

    mu=2
    dist=distributions.ZTpoisson(mu=mu)
    seq=np.arange(0,30,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTPoisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTPois(mu=2)')
    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTPois(mu=2)')

.. image:: images/pmfZTPois.png
  :width: 400

.. image:: images/cdfZTPois.png
  :width: 400


``ZMPoisson``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZMPoisson
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a Poisson distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated poisson is defined in equation :eq:`zmpois`

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmpois

Example code on the usage of the ZMPoisson class::

    from gemact import distributions
    import numpy as np

    mu=2
    p0M=0.1
    dist=distributions.ZMpoisson(mu=mu,p0M=p0M)
    seq=np.arange(0,30,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMPoisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMPois(mu=2,p0M=.1)')

    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMPois(mu=2,p0M=.1)')

.. image:: images/pmfZMPois.png
  :width: 400

.. image:: images/cdfZMPois.png
  :width: 400

``ZTBinom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZTBinom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated binomial is defined in equation :eq:`ztbinom`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztbinom

Example code on the usage of the ZTBinom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=.2
    dist=distributions.ZTbinom(n=n,
                               p=p)
    seq=np.arange(0,30,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTBinom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTBinom(n=10 p=.2)')


    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTBinom(n=10 p=.2)')
.. image:: images/pmfZTBinom.png
  :width: 400

.. image:: images/cdfZTBinom.png
  :width: 400



``ZMBinom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZMBinom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated binomial is defined in equation :eq:`zmbinom`

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmbinom

Example code on the usage of the ZMBinom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=.2
    p0M=.05
    dist=distributions.ZMbinom(n=n,p=p,p0M=p0M)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMPoisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMBinom(n=10,p=.5,p0M=.05)')

    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMBinom(n=10,p=.5,p0M=.05)')

.. image:: images/pmfZMBinom.png
  :width: 400

.. image:: images/cdfZMBinom.png
  :width: 400

``ZTGeom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZTGeom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a geometric distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated geometric is defined in equation :eq:`ztgeom`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztgeom

Example code on the usage of the ZTGeom class::

    from gemact import distributions
    import numpy as np

    p=.2
    dist=distributions.ZTgeom(p=p)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTGeom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTGeom(p=.2)')
    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTGeom(p=.2)')

.. image:: images/pmfZTGeom.png
  :width: 400

.. image:: images/cdfZTGeom.png
  :width: 400

``ZMGeom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZMGeom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a geometric distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Modified geometric is defined in equation :eq:`zmgeom`.

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmgeom

Example code on the usage of the ZMGeom class::

    from gemact import distributions
    import numpy as np

    p=.2
    p0M=.01
    dist=distributions.ZMgeom(p=p,p0M=p0M)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMGeom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMGeom(p=.2,p0M=.01)')

    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMGeom(p=.2,p0M=.01)')

.. image:: images/pmfZMGeom.png
  :width: 400

.. image:: images/cdfZMGeom.png
  :width: 400

``ZTNegBinom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZTNegBinom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a negative binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated negative binomial is defined in equation :eq:`ztnbinom`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztnbinom

Example code on the usage of the ZTNegBinom class::

    from gemact import distributions
    import numpy as np

    p=.2
    n=10
    dist=distributions.ZTnbinom(p=p,n=n)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTNbinom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTNbinom(p=.2,n=10)')

    #cdf
    plt.step(np.arange(0,100),dist.cdf(np.arange(0,100)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTNbinom(p=.2,n=10)')

.. image:: images/pmfZTnbinom.png
  :width: 400

.. image:: images/cdfZTNbinom.png
  :width: 400


``ZMNegBinom``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZTNegBinom
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a negative binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Modified negative binomial is defined in equation :eq:`zmnbinom`.

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmnbinom

``ZMLogser``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.ZMLogser
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let :math:`P(z)` denote the probability generating function of a logarithmic distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Modified logarithmic is defined in equation :eq:`zmlogser`.

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmlogser


Example code on the usage of the ZMLogser class::

    from gemact import distributions
    import numpy as np

    p=.2
    p0M=.01
    dist=distributions.ZMlogser(p=p,p0M=p0M)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMlogser::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMlogser(p=.2, p0M=.01)')
    #cdf
    plt.step(np.arange(0,10),dist.cdf(np.arange(0,10)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMlogser(p=.2, p0M=.01)')

.. image:: images/pmfZMLogser.png
  :width: 400

.. image:: images/cdfZMLogser.png
  :width: 400


``Gamma``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Gamma
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gamma.html>`_, see :cite:t:`scipy`.

.. math:: f(x, a)=\frac{x^{a-1} e^{-x}}{\Gamma(a)}
   :label: gamma

Given :math:`f(x, a)=\frac{x^{a-1} e^{-x}}{\Gamma(a)}` and :math:`x \geq 0, a>0`. :math:`\Gamma(a)` refers to the gamma function.

Example code on the usage of the Gamma class::

    from gemact import distributions
    import numpy as np

    a=2
    b=5
    dist=distributions.Gamma(a=a,
                             beta=b)
    seq=np.arange(0,100,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Gamma::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Gamma(a=2, beta=5)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Gamma(a=2, beta=5)')

.. image:: images/pdfGamma.png
  :width: 400

.. image:: images/cdfGamma.png
  :width: 400

``Exponential``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Exponential
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. math:: f(x, \theta)=\theta \cdot e^{-\theta x}
   :label: exponential

Given :math:`\theta \geq 0`. 

Example code on the usage of the Exponential class::

    from gemact import distributions
    import numpy as np

    theta=.1
    dist=distributions.Exponential(theta=theta)
    seq=np.arange(0,200,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of an Exponential::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Gamma(a=2, beta=5)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Gamma(a=2, beta=5)')

.. image:: images/pdfExponential.png
  :width: 400

.. image:: images/cdfExponential.png
  :width: 400

``InvGauss``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.InvGauss
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to :cite:t:`scipy` documentation.

.. math:: f(x, \mu)=\frac{1}{\sqrt{2 \pi x^{3}}} \exp \left(-\frac{(x-\mu)^{2}}{2 x \mu^{2}}\right)
   :label: invgamma


``InvGamma``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.InvGamma
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to :cite:t:`scipy` documentation.

.. math:: f(x, a)=\frac{x^{-a-1}}{\Gamma(a)} \exp \left(-\frac{1}{x}\right)
   :label: invgamma

Given :math:`x>=0, a>0 `. :math:`\Gamma(a)` refers to the gamma function.

``GenPareto``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.GenPareto
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.genpareto.html>`_, see :cite:t:`scipy`.


.. math:: f(x, c)=(1+c x)^{-1-1 / c}
   :label: genpareto

Given :math:`x \geq 0` if :math:`c \geq 0`. :math:`0 \leq x \leq-1 / c if c<0`.

Example code on the usage of the GenPareto class::

    from gemact import distributions
    import numpy as np

    c=.4
    loc=0
    scale=0.25

    dist=distributions.Genpareto(c=c,
                                loc=loc,
                                scale=scale)

    seq=np.arange(0,100,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a GenPareto::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=50,
             density=True)
    plt.title('Probability density function, ~GenPareto(a=2, beta=5)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~GenPareto(a=2, beta=5)')

.. image:: images/pdfGenPareto.png
  :width: 400

.. image:: images/cdfGenPareto.png
  :width: 400

``Lognormal``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Lognormal
   :members:

^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.lognorm.html>`_, see :cite:t:`scipy`.

.. math:: f(x, s)=\frac{1}{s x \sqrt{2 \pi}} \exp \left(-\frac{\log ^{2}(x)}{2 s^{2}}\right)
   :label: lognorm

Given :math:`x>0, s>0`.

Example code on the usage of the Lognormal class::

    from gemact import distributions
    import numpy as np

    s=2
    dist=distributions.Lognorm(s=s)

    seq=np.arange(0,100,.1)
    nsim=int(1e+08)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a LogNorm::

    import matplotlib.pyplot as plt
    #pmf
    plt.hist(dist.rvs(nsim),
             bins=20,
             density=True)
    plt.title('Probability density function, ~LogNormal(s=2)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function, ~LogNormal(s=2)')

.. image:: images/pdfLogNormal.png
  :width: 400

.. image:: images/cdfLogNormal.png
  :width: 400

``Burr12``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Burr12
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `Scipy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.burr12.html>`_ , see :cite:t:`scipy`.

.. math:: f(x, c, d)=c d x^{c-1} /\left(1+x^{c}\right)^{d+1}
   :label: burr12

Given :math:`x>=0 and c, d>0`.

Example code on the usage of the Burr12 class::

    from gemact import distributions
    import numpy as np

    c=2
    d=3
    dist=distributions.Burr12(c=c,
                              d=d)

    seq=np.arange(0,100,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Burr12::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Burr12(c=c,d=d)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Burr12(c=c,d=d)')

.. image:: images/pdfBurr12.png
  :width: 400

.. image:: images/cdfBurr12.png
  :width: 400



``Dagum``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Dagum
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mielke.html>`_ ,see :cite:t:`scipy`.

.. math:: f(x, k, s)=\frac{k x^{k-1}}{\left(1+x^{s}\right)^{1+k / s}}
   :label: dagum

Given :math:`x>0` , :math:`k,s>0`.


Example code on the usage of the Dagum class::

    from gemact import distributions
    import numpy as np

    d=2
    s=4.2
    dist=distributions.Dagum(d=d,
                             s=s)

    seq=np.arange(0,3,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Dagum::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Dagum(d=4,s=2)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Dagum(d=c,s=4.2)')

.. image:: images/pdfDagum.png
  :width: 400

.. image:: images/cdfDagum.png
  :width: 400


``Weibull``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Weibull
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.weibull_min.html>`_ , see :cite:t:`scipy`.

.. math:: f(x, c)=c x^{c-1} \exp \left(-x^{c}\right)
   :label: weibull_min

Given :math:`x>0` , :math:`c>0`.



Example code on the usage of the Weibull class::

    from gemact import distributions
    import numpy as np

    c=2.2
    dist=distributions.Weibull_min(c=c)

    seq=np.arange(0,3,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))


Then, use ``matplotlib`` library to print the pmf and the cdf of a Weibull_min::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Weibull_min(s=2.2)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Invweibull(c=7.2)')

.. image:: images/pdfWeibull_min.png
  :width: 400

.. image:: images/cdfWeibull_min.png
  :width: 400

``InvWeibull``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.InvWeibull
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to :cite:t:`scipy` `documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.invweibull.html>`_.

.. math:: f(x, c)=c x^{-c-1} \exp \left(-x^{-c}\right)
   :label: invweibull

Given :math:`x>0` , :math:`c>0`.


Example code on the usage of the InvWeibull class::

    from gemact import distributions
    import numpy as np

    c=7.2
    dist=distributions.Invweibull(c=c)

    seq=np.arange(0,3,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Invweibull::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Invweibull(c=7.2)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Invweibull(c=7.2)')

.. image:: images/pdfInvweibull.png
  :width: 400

.. image:: images/cdfInvweibull.png
  :width: 400


``Beta``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.Beta
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html>`_, :cite:t:`scipy` .

.. math:: f(x, a, b)=\frac{\Gamma(a+b) x^{a-1}(1-x)^{b-1}}{\Gamma(a) \Gamma(b)}
   :label: beta

Given :math:`0<=x<=1, a>0, b>0` , :math:`\Gamma` is the gamma function.

Example code on the usage of the Beta class::

    from gemact import distributions
    import numpy as np

    a=2
    b=5
    dist=distributions.Beta(a=a,
                            b=b)

    seq=np.arange(0,1,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Beta::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Beta(a=2,b=5)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Beta(a=2,b=5)')

.. image:: images/pdfBeta.png
  :width: 400

.. image:: images/cdfBeta.png
  :width: 400


``GenBeta``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: distributions.GenBeta
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. math:: f(x)=\frac{\Gamma(shape_1+shape_2)}{\Gamma(shape_1) \Gamma(shape_2)}(\frac{x}{scale})^{shape_1 shape_3}\left(1-(\frac{x}{scale})^{shape_3}\right)^{shape_2-1} \frac{shape_3}{x}
   :label: genbeta

Given :math:`0<=x<=scale, shape_1>0, shape_2>0` , :math:`\Gamma` is the gamma function.

Example code on the usage of the GenBeta class::

    from gemact import distributions
    import numpy as np

    shape1=1
    shape2=2
    shape3=3
    scale=4

    dist=GenBeta(shape1=shape1,
                 shape2=shape2,
                 shape3=shape3,
                 scale=scale)

    seq=np.arange(0,1,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))


Then, use ``matplotlib`` library to print the pmf and the cdf of a GenBeta::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~GenBeta(shape1=1,shape2=2,shape3=3,scale=4)')
    #cdf
    plt.plot(np.arange(-1,8,.001),dist.cdf(np.arange(-1,8,.001)))
    plt.title('Cumulative distribution function,  ~GenBeta(shape1=1,shape2=2,shape3=3,scale=4)')


.. image:: images/pdfGenBeta.png
  :width: 400

.. image:: images/cdfGenBeta.png
  :width: 400

The ``copulas`` module
---------------------------

Guide to copulas

``ClaytonCopula``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: copulas.ClaytonCopula
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^

Clayton copula cumulative density function:

.. math:: C_{\delta}^{C l}\left(u_{1}, \ldots, u_{d}\right)=\left(u_{1}^{-\delta}+u_{2}^{-\delta}+\cdots+u_{d}^{-\delta}-d+1\right)^{-1 / \delta}

Given :math:`u_{k} \in[0,1], k=1, \ldots, d` , :math:`\delta > 0` .


Example code on the usage of the ClaytonCopula class::

    from gemact import copulas

    clayton_c=copulas.ClaytonCopula(par=1.4,
                                    dim=2)
    clayton_c.rvs(size=100,
                  random_state= 42)



``FrankCopula``
~~~~~~~~~~~~~~~~~~~~


.. autoclass:: copulas.FrankCopula
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^



Frank copula cumulative density function:

.. math:: C_{\theta}^{F r}\left(u_{1}, \ldots, u_{d}\right)=-\frac{1}{\delta} \log \left(1+\frac{\prod_{i}\left(\exp \left(-\delta u_{i}\right)-1\right)}{\exp (-\delta)-1}\right)

Given :math:`u_{k} \in[0,1], k=1, \ldots, d` , :math:`\delta >= 0` .


Example code on the usage of the FrankCopula class::

    from gemact import copulas
    frank_c=copulas.FrankCopula(par=1.4,
                                dim=2)
    frank_c.rvs(size=100,
                  random_state= 42)

``GumbelCopula``
~~~~~~~~~~~~~~~~~~~~

.. autoclass:: copulas.GumbelCopula
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Gumbel copula cumulative density function:

.. math:: C_{\theta}^{G u}\left(u_{1}, \ldots, u_{d}\right)=\exp \left(-\left(\sum_{i}\left(-\log u_{i}\right)^{\delta}\right)^{1 / \delta}\right)

Given :math:`u_{k} \in[0,1], k=1, \ldots, d` , :math:`\delta >= 1` .


Example code on the usage of the GumbelCopula class::

    from gemact import copulas

    gumbel_c=copulas.GumbelCopula(par=1.4,
                                  dim=2)
    gumbel_c.rvs(size=100,
                  random_state= 42)


``GaussCopula``
~~~~~~~~~~~~~~~~~~~



.. autoclass:: copulas.GaussCopula
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Gauss copula cumulative density function is based on the scipy function `multivariate_normal`.
For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.multivariate_normal.html>`_, :cite:t:`scipy` .

.. math:: f(x)=\frac{1}{\sqrt{(2 \pi)^{k} \operatorname{det} \Sigma}} \exp \left(-\frac{1}{2}(x-\mu)^{T} \Sigma^{-1}(x-\mu)\right)


Example code on the usage of the GaussCopula class::

    from gemact import copulas

    corr_mx=np.array([[1,.4],[.4,1]])

    gauss_c=copulas.GaussCopula(corr=corr_mx)
    gauss_c.rvs(size=100,
                  random_state= 42)

``TCopula``
~~~~~~~~~~~~~~~~~~~

.. autoclass:: copulas.TCopula
   :members:

Parametrization
^^^^^^^^^^^^^^^^^^^^^^^^^^


T copula cumulative density function:

.. math:: C_{v, C}^{t}\left(u_{1}, \ldots, u_{d}\right)=\boldsymbol{t}_{v, C}\left(t_{v}^{-1}\left(u_{1}\right), \ldots, t_{v}^{-1}\left(u_{d}\right)\right)

Given :math:`u_{k} \in[0,1], k=1, \ldots, d`. :math:`t_{v}^{-1}` is the inverse student’s t function and :math:`\boldsymbol{t}_{v, C}` is the cumulative distribution function of the multivariate student’s t distribution with a given mean and correlation matrix C.
Degrees of freedom :math:`v>0` .

Example code on the usage of the TCopula class::

    from gemact import copulas

    corr_mx=np.array([[1,.4],[.4,1]])

    t_c=copulas.TCopula(corr=corr_mx,
                        df=5)
    t_c.rvs(size=100,
            random_state= 42)

References
=================
.. bibliography::



