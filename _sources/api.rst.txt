API reference guide
=================

``LossModel``
---------------

.. autoclass:: lossmodel.LossModel
   :members:
   :inherited-members:


(Re)insurance pricing
~~~~~~~~~~~~~~~~~~~~~~~~~~~

GEMAct pricing model is based on the collective risk theory. 

.. math:: \widetilde{X}=\sum_{i=1}^{\widetilde{N}} \widetilde{{Z_i}}
   :label: crm

Denote the pure reinsurance premium as :math:`P= \mathbb{E}\left( X \right)`

In order to price our (re)insurance contracts we model the company aggregate claim cost under the following assumptions.

* :math:`\widetilde{X} \sim g(X)` and :math:`\widetilde{Z_i} \sim f(Z)`
*  Given :math:`\widetilde{N}=n`,  the severity :math:`\widetilde{Z_1},\ldots,\widetilde{Z_n}` is i.i.d and does not depend on :math:`n`.
* :math:`\widetilde{N}` does not depend on :math:`\widetilde{Z_1},\ldots,\widetilde{Z_n}` in any way.

Pricing models
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Assume: 

.. math:: X^{\prime}=\min (\max (0, X-L), (K+1) \cdot u)
   :label: crmRE

Given :math:`\widetilde{X}=\sum_{i=1}^{\widetilde{N}} \widetilde{Y}_{i}`, where :math:`\widetilde{Y}_i` is defined in equation :eq:`crmRE`.

.. math:: \widetilde{Y}_{i}=\min \left(\max \left(0, \widetilde{Z}_{i}-d\right), u\right)
   :label: XLpremium

Equation :eq:`XLpremium` shows the reinsurance premium for excess of loss treaties. It is possible to obtain a plain-vanilla XL with :math:`L=0`, :math:`K=+\infty` and :math:`c=0`.

.. math:: P=\frac{D_{L K}}{1+\frac{1}{m} \sum_{k=1}^{K} c_{k} d_{L, k-1}}
   :label: reinstatementsLayer

GEMAct pricing model is based on  :cite:t:`b:kp` and  :cite:t:`sundt`. 

Refer again to :cite:t:`b:kp` for the recursive formula to compute the collective risk model and to :cite:t:`embrechts` for the Fast Fourier transform to approximate the Discrete Fourier Transform of the collective risk model.


Examples
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``LossModel`` can be used to price reinsurance contracts.

An example of pricing with reinstatements::

   from gemact import LossModel
   lossm=LossModel(
             method='fft',
             fpar={'mu':.5},
             fdist= 'poisson',
             spar={'loc':0,'scale': 83.33, 'c’: 0.833}, 
             sdist='genpareto',
             u=100,
             discretizationmethod='massdispersal',
             m=int(10000),
             h=.01,
             n=int(100000),
             L=0,
             K=1,
             c=1)

The output of ``lossm.Pricing()``:

+--------------------------------------------------+-------------+--------+
| Contractual limits                               | parameter   | value  | 
|                                                  |             |        |                                   
+==================================================+=============+========+
| deductible                                       |  d          |    0   |       
+--------------------------------------------------+-------------+--------+
| priority (severity)                              |  u          |  100   |    
+--------------------------------------------------+-------------+--------+
| priority (aggregate)                             |  L          |    0   |       
+--------------------------------------------------+-------------+--------+
| alpha(qs)                                        |  qs         |    1   |
+--------------------------------------------------+-------------+--------+
| reinstatements                                   |  K          |    1   |
+--------------------------------------------------+-------------+--------+
| Pure premium                                     |  P          | 24.98  |
+--------------------------------------------------+-------------+--------+

``LossModel`` can be used to model the aggregate cost of claims::
   
      from gemact LossModel
      lm_fft=LossModel(
                 method='fft',
                 fpar=fpar,
                 fdist=frequency_,
                 spar=spar,
                 sdist=severity_,
                 d=d_,
                 u=u_,
                 m=int(1e+03),
                 h=1,
                 n=int(1e+05)
               )

      print('FFT',lm_fft.empiricalmoments())
      # FFT 7.192555408630492


``Severity``
----------------

.. autoclass:: lossmodel.Severity
   :members:

Severity discretization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to pass from a continuous distribution to an arithmetic distribution, it is important to preserve the distribution properties either locally or globally. Given a span :math:`h` and :math:`M` the last available point, in :cite:t:`b:kp` there are two available solutions. 

**Method of mass dispersal**

.. math:: f_{0}=\operatorname{Pr}\left(\widetilde{Y}<\frac{h}{2}\right)=F_{\widetilde{Y}}\left(\frac{h}{2}-0\right) 
   :label: md1

.. math:: f_{j}=F_{\widetilde{Y}}\left(j h+\frac{h}{2}-0\right)-F_{\widetilde{Y}}\left(j h-\frac{h}{2}-0\right), \quad j=1,2, \ldots, M-1  
   :label: md2


.. math:: f_{M}=1-F_{X}[(M-0.5) h-0]
   :label: md3

**Method of local moments matching**

The following approach is applied to preserve the global mean of the distribution.

.. math:: f_0 = m^0_0
   :label: lm1

.. math:: f_j = m^{j}_0+ m^{j-1}_1 , \quad j=0,1, \ldots, M
   :label: lm2

.. math:: \sum_{j=0}^{1}\left(x_{k}+j h\right)^{r} m_{j}^{k}=\int_{x_{k}-0}^{x_{k}+ h-0} x^{r} d F_{X}(x), \quad r=0,1
   :label: lm3

.. math:: m_{j}^{k}=\int_{x_{k}-0}^{x_{k}+p h-0} \prod_{i \neq j} \frac{x-x_{k}-i h}{(j-i) h} d F_{X}(x), \quad j=0,1
   :label: lm4


Examples
~~~~~~~~~~

A simple code implementation of ``Severity``. How to make a distribution discrete according to local moment matching or mass dispersal::

   from gemact import Severity
   import numpy as np

   m_= 80000 
   h_= 1. 
   d_= 100 
   u_= 4500 
   spar_ = {'a' : 3000, 'scale' : 1/3} 
   severity_ = 'gamma'
   mysv = Severity(
      spar=spar_, 				
         d=d_,
         u=u_,
         sdist=severity_,
         m=m_,
         h=h_
   ) 

   massD = mysv.massDispersal()
   localM = mysv.localMoments()
   massD = mysv.massDispersal()
   localM = mysv.localMoments()

   #mean mass dispersal
   meanMD = np.sum(massD['severity_seq']*massD['fj'])
   #mean local moments matching
   meanLM = np.sum(localM['severity_seq']*localM['fj'])


``LossReserve``
------------------

.. automodule:: lossreserve
   :members:


Claims reserving 
~~~~~~~~~~~~~~~~~~~~~~~~~~~

GEMAct provides a software implementation of average cost methods for claims reserving based on the collective risk model framework. 

The methods implemented in GEMAct are the Fisher-Lange in :cite:t:`fisher99` the collective risk model for claims reserving in :cite:t:`ricotta16`.

GEMAct allows for tail estimates and assumes the triangular inputs to be provided as a ``numpy.ndarray`` with two equal dimensions ``(I,J)``, where ``I=J``.

The aim of average cost methods is to model incremental payments as in equation :eq:`acmethods`.

.. math:: P_{i,j}=n_{i,j} \cdot m_{i,j}
   :label: acmethods

where :math:`n_{i,j}` is the number of payments in the cell :math:`i,j` and :math:`m_{i,j}` is the average cost in the cell :math:`i,j`.

Example
~~~~~~~~~

It is possible to use the module ``gemdata`` to test GEMAct average cost methods:: 

   ip_= gemact.gemdata.IPtriangle 
   in_= gemact.gemdata.in_triangle 
   cp_= gemact.gemdata.cased_amount_triangle 
   cn_= gemact.gemdata.cased_number_triangle 
   reported_= gemact.gemdata.reported_ 
   infl_= gemact.gemdata.claims_inflation 
   rm_='fisherlange' 
   tail_=True 

An example of Fisher-Lange implementation::  

   lr = gemact.LossReserve(tail=tail_,
               incremental_payments=ip_,
               cased_payments=cp_,
               cased_number=cn_,
               reported_claims=reported_,
               incurred_number=in_,
               reserving_method=rm_,
               claims_inflation=infl_)

An example of CRM implementation. Observe the CRM for reserving requires additional parameters:: 

   lr = gemact.LossReserve(tail=tail_,
               incremental_payments=ip_,
               cased_payments=cp_,
               cased_number=cn_,
               reported_claims=reported_,
               incurred_number=in_,
               ntr_sim=int(1000),
               reserving_method="crm",
               mixingfpar={'a':1/.08**2,'scale':.08**2},
               mixingspar={'a':1/.08**2,'scale':.08**2},
               claims_inflation=infl_)

``LossAggregation``
---------------------

.. autoclass:: lossaggregation.LossAggregation
   :members: None

Risks aggregation
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. math:: P\left[ X_1 +\ldots +X_d \right] \approx P_n(s)
   :label: pty

The probability in equation :eq:`pty` can be approximated iteratively via the AEP algorithm, which is implemented for the first time in the GEMAct package, under the following assumptions:

Assuming:

* :math:`𝑋=(X_i, \ldots, X_d)` vector of strictly positive random components.

* The joint c.d.f. :math:`H(x_1,…,x_d )=P\left[ X_1 +\ldots +X_d \right]` is known or it can be computed numerically.

Refer to :cite:t:`arbenz11` for an extensive explanation on the AEP algorithm.

Examples
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Example code under a gumbel assumption::

   la=gemact.LossAggregation(s_la=1,
                     n_la=7,
                     m1='genpareto',
                     m1par={'loc':0,
                           'scale':1/.9,
                           'c':1/.9},
                     m2='genpareto',
                     m2par={'loc':0,
                           'scale':1/1.8,
                           'c':1/1.8},
                     copdist='gumbel',
                     coppar={'par':1.2})
   #output is kept in the out attribute
   print(la.out)

The ``distributions`` module
------------------------------------


The following table summarizes the distribution supported by GemAct and Scipy.

+--------------------------------------------------+-------------+--------+--------+
| Distribution                                     | Support     | GemAct | SciPy  | 
|                                                  |             |        |        |
+==================================================+=============+========+========+
| The Burr Distribution.                           |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+ 
| The Generalized Pareto Distribution.             |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+ 
| The Inverse Burr Distribution (Dagum).           |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+ 
| The Inverse Gamma Distribution.                  |  continuous |    v   |   v    |                            
+--------------------------------------------------+-------------+--------+--------+ 
|The Inverse Gaussian Distribution.                |  continuous |    v   |   v    |
+--------------------------------------------------+-------------+--------+--------+ 
|The Inverse Paralogistic Distribution.            |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+ 
|The Weibull Distribution.                         |  continuous |    v   |   v    |                         
+--------------------------------------------------+-------------+--------+--------+
|The Inverse Weibull Distribution.                 |  continuous |    v   |   v    |                         
+--------------------------------------------------+-------------+--------+--------+
|The Paralogistic Distribution.                    |  continuous |    v   |   v    |                      
+--------------------------------------------------+-------------+--------+--------+
|The Pareto Distribution.                          |  continuous |    v   |   v    |                      
+--------------------------------------------------+-------------+--------+--------+
|The Single-parameter Pareto Distribution.         |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Pareto II Distribution.                       |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Pareto III Distribution.                      |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Pareto IV Distribution.                       |  continuous |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Beta distribution.                            |continuous   |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Poisson Distribution.                         | discrete    |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Binomial Distribution.                        | discrete    |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Geometric Distribution.                       | discrete    |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Negative Binomial Distribution.               | discrete    |    v   |   v    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Modified Binomial Distribution.          | discrete    |    v   |   x    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Modified Geometric Distribution.         | discrete    |    v   |   x    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Modified Logarithmic Distribution.       | discrete    |    v   |   x    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Modified Negative Binomial Distribution  | discrete    |    v   |   x    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Modified Poisson Distribution            | discrete    |    v   |   x    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Truncated Binomial Distribution          | discrete    |    v   |   x    |
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Truncated Geometric Distribution         | discrete    |    v   |   x    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Truncated Negative Binomial Distribution | discrete    |    v   |   x    |                           
+--------------------------------------------------+-------------+--------+--------+
|The Zero-Truncated Poisson Distribution           | discrete    |    v   |   x    |                            
+--------------------------------------------------+-------------+--------+--------+


``Poisson``
------------------

.. autoclass:: distributions.Poisson
   :members:


Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.poisson.html>`_, see :cite:t:`scipy`.

.. math:: f(k)=\exp (-\mu) \frac{\mu^{k}}{k !}
   :label: poisson

Given :math:`\mu \geq 0` and :math:`k \geq 0`.

Example code on the usage of the Poisson class::

    from gemact import distributions
    import numpy as np

    mu=4
    dist=distributions.Poisson(mu=mu)
    seq=np.arange(0,20)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Poisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~Poisson(mu=4)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~ Poisson(mu=4)')

.. image:: images/pmfPois.png
  :width: 400

.. image:: images/cdfPois.png
  :width: 400

``Binom``
------------------

.. autoclass:: distributions.Binom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binom.html>`_, see :cite:t:`scipy`.

.. math:: f(k)=\left(
   \begin{array}{l}
      n \\
      k
   \end{array} \right) p^{k}(1-p)^{n-k}
   :label: binomial

for :math:`k \in\{0,1, \ldots, n\}, 0 \leq p \leq 1`

Example code on the usage of the Binom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=0.5
    dist=distributions.Binom(n=n,p=p)
    seq=np.arange(0,20)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))
Then, use ``matplotlib`` library to print the pmf and the cdf of a Poisson::

    import matplotlib.pyplot as plt
    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~Binom(n=10,p=0.5)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~Binom(n=10,p=0.5)')

.. image:: images/pmfBinom.png
  :width: 400

.. image:: images/cdfBinom.png
  :width: 400

``Geom``
------------------

.. autoclass:: distributions.Geom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.geom.html>`_, see :cite:t:`scipy`..

.. math:: f(k)=(1-p)^{k-1} p
   :label: geom

for :math:`k \geq 1,0<p \leq 1`

Example code on the usage of the Geom class::

    from gemact import distributions
    import numpy as np

    p=0.8
    dist=distributions.Geom(p=p)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))
Then, use ``matplotlib`` library to print the pmf and the cdf of a Geom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~Geom(p=0.8)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~Geom(p=0.8)')

.. image:: images/pmfGeom.png
  :width: 400

.. image:: images/cdfGeom.png
  :width: 400

``NegBinom``
------------------

.. autoclass:: distributions.NegBinom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.nbinom.html>`_, see :cite:t:`scipy`.

.. math:: f(k)=\left(\begin{array}{c}
      k+n-1 \\
      n-1
   \end{array}\right) p^{n}(1-p)^{k}
   :label: geom

for :math:`k \geq 0,0<p \leq 1`

Example code on the usage of the NegBinom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=.5
    dist=distributions.Nbinom(n=n,p=p)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Theoretical mean',dist.mean())
    print('Variance',variance)
    print('Theoretical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a NBinom::

    import matplotlib.pyplot as plt
    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~NBinom(n=10,p=0.8)')

    #cdf
    plt.step(np.arange(-2,20),dist.cdf(np.arange(-2,20)),'-', where='pre')
    plt.title('Cumulative distribution function, ~NBinom(n=10,p=0.8)')

.. image:: images/pmfNBinom.png
  :width: 400

.. image:: images/cdfNBinom.png
  :width: 400

``ZTpoisson``
------------------

.. autoclass:: distributions.ZTPoisson
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a Poisson distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated poisson is defined in equation :eq:`ztpois`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztpois


Example code on the usage of the ZTPoisson class::

    from gemact import distributions
    import numpy as np

    mu=2
    dist=distributions.ZTpoisson(mu=mu)
    seq=np.arange(0,30,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTPoisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTPois(mu=2)')
    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTPois(mu=2)')

.. image:: images/pmfZTPois.png
  :width: 400

.. image:: images/cdfZTPois.png
  :width: 400


``ZMPoisson``
------------------

.. autoclass:: distributions.ZMPoisson
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a Poisson distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated poisson is defined in equation :eq:`zmpois`

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmpois

Example code on the usage of the ZMPoisson class::

    from gemact import distributions
    import numpy as np

    mu=2
    p0M=0.1
    dist=distributions.ZMpoisson(mu=mu,p0M=p0M)
    seq=np.arange(0,30,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMPoisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMPois(mu=2,p0M=.1)')

    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMPois(mu=2,p0M=.1)')

.. image:: images/pmfZMPois.png
  :width: 400

.. image:: images/cdfZMPois.png
  :width: 400

``ZTBinom``
------------------

.. autoclass:: distributions.ZTBinom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated binomial is defined in equation :eq:`ztbinom`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztbinom

Example code on the usage of the ZTBinom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=.2
    dist=distributions.ZTbinom(n=n,
                               p=p)
    seq=np.arange(0,30,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTBinom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTBinom(n=10 p=.2)')


    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTBinom(n=10 p=.2)')
.. image:: images/pmfZTBinom.png
  :width: 400

.. image:: images/cdfZTBinom.png
  :width: 400



``ZMBinom``
------------------

.. autoclass:: distributions.ZMBinom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated binomial is defined in equation :eq:`zmbinom`

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmbinom

Example code on the usage of the ZMBinom class::

    from gemact import distributions
    import numpy as np

    n=10
    p=.2
    p0M=.05
    dist=distributions.ZMbinom(n=n,p=p,p0M=p0M)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMPoisson::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMBinom(n=10,p=.5,p0M=.05)')

    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMBinom(n=10,p=.5,p0M=.05)')

.. image:: images/pmfZMBinom.png
  :width: 400

.. image:: images/cdfZMBinom.png
  :width: 400

``ZTGeom``
------------------

.. autoclass:: distributions.ZTGeom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a geometric distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated geometric is defined in equation :eq:`ztgeom`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztgeom

Example code on the usage of the ZTGeom class::

    from gemact import distributions
    import numpy as np

    p=.2
    dist=distributions.ZTgeom(p=p)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTGeom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTGeom(p=.2)')
    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTGeom(p=.2)')

.. image:: images/pmfZTGeom.png
  :width: 400

.. image:: images/cdfZTGeom.png
  :width: 400

``ZMGeom``
------------------

.. autoclass:: distributions.ZMgeom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a geometric distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Modified geometric is defined in equation :eq:`zmgeom`.

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmgeom

Example code on the usage of the ZMGeom class::

    from gemact import distributions
    import numpy as np

    p=.2
    p0M=.01
    dist=distributions.ZMgeom(p=p,p0M=p0M)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMGeom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMGeom(p=.2,p0M=.01)')

    #cdf
    plt.step(np.arange(0,20),dist.cdf(np.arange(0,20)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMGeom(p=.2,p0M=.01)')

.. image:: images/pmfZMGeom.png
  :width: 400

.. image:: images/cdfZMGeom.png
  :width: 400

``ZTNegBinom``
------------------

.. autoclass:: distributions.ZTNegBinom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a negative binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Truncated negative binomial is defined in equation :eq:`ztnbinom`.

.. math:: P^{T}(z)=\frac{P(z)-p_{0}}{1-p_{0}}
   :label: ztnbinom

Example code on the usage of the ZTNegBinom class::

    from gemact import distributions
    import numpy as np

    p=.2
    n=10
    dist=distributions.ZTnbinom(p=p,n=n)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZTNbinom::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZTNbinom(p=.2,n=10)')

    #cdf
    plt.step(np.arange(0,100),dist.cdf(np.arange(0,100)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZTNbinom(p=.2,n=10)')

.. image:: images/pmfZTnbinom.png
  :width: 400

.. image:: images/cdfZTNbinom.png
  :width: 400


``ZMNegBinom``
------------------

.. autoclass:: distributions.ZTNegBinom
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a negative binomial distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Modified negative binomial is defined in equation :eq:`zmnbinom`.

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmnbinom

``ZMLogser``
------------------

.. autoclass:: distributions.ZMLogser
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

Let :math:`P(z)` denote the probability generating function of a logarithmic distribution. 

:math:`p_{0}` is :math:`p_{0}=P[z=0]`.

The probability generating function of a Zero-Modified logarithmic is defined in equation :eq:`zmlogser`.

.. math:: P^{M}(z)=p_{0}^{M}+\frac{1-p_{0}^{M}}{1-p_{0}}\left[P(z)-p_{0}\right]
   :label: zmlogser


Example code on the usage of the ZMLogser class::

    from gemact import distributions
    import numpy as np

    p=.2
    p0M=.01
    dist=distributions.ZMlogser(p=p,p0M=p0M)
    seq=np.arange(0,100,.001)
    nsim=int(1e+05)

    # Compute the mean via pmf
    mean=np.sum(dist.pmf(seq)*seq)
    variance=np.sum(dist.pmf(seq)*(seq-mean)**2)

    print('Mean',mean)
    print('Variance',variance)
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a ZMlogser::

    import matplotlib.pyplot as plt

    #pmf
    plt.vlines(x=seq, ymin=0, ymax=dist.pmf(seq))
    plt.title('Probability mass function, ~ZMlogser(p=.2, p0M=.01)')
    #cdf
    plt.step(np.arange(0,10),dist.cdf(np.arange(0,10)),'-', where='pre')
    plt.title('Cumulative distribution function,  ~ZMlogser(p=.2, p0M=.01)')

.. image:: images/pmfZMLogser.png
  :width: 400

.. image:: images/cdfZMLogser.png
  :width: 400


``Gamma``
------------------

.. autoclass:: distributions.Gamma
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gamma.html>`_, see :cite:t:`scipy`.

.. math:: f(x, a)=\frac{x^{a-1} e^{-x}}{\Gamma(a)}
   :label: gamma

Given :math:`f(x, a)=\frac{x^{a-1} e^{-x}}{\Gamma(a)}` and :math:`x \geq 0, a>0`. :math:`\Gamma(a)` refers to the gamma function.

Example code on the usage of the Gamma class::

    from gemact import distributions
    import numpy as np

    a=2
    b=5
    dist=distributions.Gamma(a=a,
                             beta=b)
    seq=np.arange(0,100,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Gamma::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Gamma(a=2, beta=5)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Gamma(a=2, beta=5)')

.. image:: images/pdfGamma.png
  :width: 400

.. image:: images/cdfGamma.png
  :width: 400

``Exponential``
------------------

.. autoclass:: distributions.Exponential
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

.. math:: f(x, \theta)=\theta \cdot e^{-\theta x}
   :label: exponential

Given :math:`\theta \geq 0`. 

Example code on the usage of the Exponential class::

    from gemact import distributions
    import numpy as np

    theta=.1
    dist=distributions.Exponential(theta=theta)
    seq=np.arange(0,200,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of an Exponential::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Gamma(a=2, beta=5)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Gamma(a=2, beta=5)')

.. image:: images/pdfExponential.png
  :width: 400

.. image:: images/cdfExponential.png
  :width: 400

``InvGauss``
------------------

.. autoclass:: distributions.InvGauss
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to :cite:t:`scipy` documentation.

.. math:: f(x, \mu)=\frac{1}{\sqrt{2 \pi x^{3}}} \exp \left(-\frac{(x-\mu)^{2}}{2 x \mu^{2}}\right)
   :label: invgamma


``InvGamma``
------------------

.. autoclass:: distributions.InvGamma
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to :cite:t:`scipy` documentation.

.. math:: f(x, a)=\frac{x^{-a-1}}{\Gamma(a)} \exp \left(-\frac{1}{x}\right)
   :label: invgamma

Given :math:`x>=0, a>0 `. :math:`\Gamma(a)` refers to the gamma function.

``GenPareto``
------------------

.. autoclass:: distributions.GenPareto
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.genpareto.html>`_, see :cite:t:`scipy`.


.. math:: f(x, c)=(1+c x)^{-1-1 / c}
   :label: genpareto

Given :math:`x \geq 0` if :math:`c \geq 0`. :math:`0 \leq x \leq-1 / c if c<0`.

Example code on the usage of the GenPareto class::

    from gemact import distributions
    import numpy as np

    c=.4
    loc=0
    scale=0.25

    dist=distributions.Genpareto(c=c,
                                loc=loc,
                                scale=scale)

    seq=np.arange(0,100,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a GenPareto::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=50,
             density=True)
    plt.title('Probability density function, ~GenPareto(a=2, beta=5)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~GenPareto(a=2, beta=5)')

.. image:: images/pdfGenPareto.png
  :width: 400

.. image:: images/cdfGenPareto.png
  :width: 400

``Lognormal``
------------------

.. autoclass:: distributions.Lognormal
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.lognorm.html>`_, see :cite:t:`scipy`.

.. math:: f(x, s)=\frac{1}{s x \sqrt{2 \pi}} \exp \left(-\frac{\log ^{2}(x)}{2 s^{2}}\right)
   :label: lognorm

Given :math:`x>0, s>0`.

Example code on the usage of the Lognormal class::

    from gemact import distributions
    import numpy as np

    s=2
    dist=distributions.Lognorm(s=s)

    seq=np.arange(0,100,.1)
    nsim=int(1e+08)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a LogNorm::

    import matplotlib.pyplot as plt
    #pmf
    plt.hist(dist.rvs(nsim),
             bins=20,
             density=True)
    plt.title('Probability density function, ~LogNormal(s=2)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function, ~LogNormal(s=2)')

.. image:: images/pdfLogNorm.png
  :width: 400

.. image:: images/cdfLogNorm.png
  :width: 400

``Burr12``
------------------

.. autoclass:: distributions.Burr12
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `Scipy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.burr12.html>`_ , see :cite:t:`scipy`.

.. math:: f(x, c, d)=c d x^{c-1} /\left(1+x^{c}\right)^{d+1}
   :label: burr12

Given :math:`x>=0 and c, d>0`.

Example code on the usage of the Burr12 class::

    from gemact import distributions
    import numpy as np

    c=2
    d=3
    dist=distributions.Burr12(c=c,
                              d=d)

    seq=np.arange(0,100,.1)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))

Then, use ``matplotlib`` library to print the pmf and the cdf of a Burr12::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Burr12(c=c,d=d)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Burr12(c=c,d=d)')

.. image:: images/pdfBurr12.png
  :width: 400

.. image:: images/cdfBurr12.png
  :width: 400



``Dagum``
------------------

.. autoclass:: distributions.Dagum
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mielke.html>`_ ,see :cite:t:`scipy`.

.. math:: f(x, k, s)=\frac{k x^{k-1}}{\left(1+x^{s}\right)^{1+k / s}}
   :label: dagum

Given :math:`x>0` , :math:`k,s>0`.


Example code on the usage of the Dagum class::

    from gemact import distributions
    import numpy as np

    d=2
    s=4.2
    dist=distributions.Dagum(d=d,
                             s=s)

    seq=np.arange(0,3,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))
Then, use ``matplotlib`` library to print the pmf and the cdf of a Dagum::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Dagum(d=4,s=2)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Dagum(d=c,s=4.2)')

.. image:: images/pdfDagum.png
  :width: 400

.. image:: images/cdfDagum.png
  :width: 400


``Weibull``
------------------

.. autoclass:: distributions.Weibull
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.weibull_min.html>`_ , see :cite:t:`scipy`.

.. math:: f(x, c)=c x^{c-1} \exp \left(-x^{c}\right)
   :label: weibull_min

Given :math:`x>0` , :math:`c>0`.



Example code on the usage of the Weibull class::

    from gemact import distributions
    import numpy as np

    c=2.2
    dist=distributions.Weibull_min(c=c)

    seq=np.arange(0,3,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))
Then, use ``matplotlib`` library to print the pmf and the cdf of a Weibull_min::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Weibull_min(s=2.2)')

    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Invweibull(c=7.2)')

.. image:: images/pdfWeibull_min.png
  :width: 400

.. image:: images/cdfWeibull_min.png
  :width: 400

``InvWeibull``
------------------

.. autoclass:: distributions.InvWeibull
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to :cite:t:`scipy` `documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.invweibull.html>`_.

.. math:: f(x, c)=c x^{-c-1} \exp \left(-x^{-c}\right)
   :label: invweibull

Given :math:`x>0` , :math:`c>0`.


Example code on the usage of the InvWeibull class::

    from gemact import distributions
    import numpy as np

    c=7.2
    dist=distributions.Invweibull(c=c)

    seq=np.arange(0,3,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))
Then, use ``matplotlib`` library to print the pmf and the cdf of a Invweibull::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Invweibull(c=7.2)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Invweibull(c=7.2)')

.. image:: images/pdfInvweibull.png
  :width: 400

.. image:: images/cdfInvweibull.png
  :width: 400


``Beta``
------------------

.. autoclass:: distributions.Beta
   :members:

Parametrization
~~~~~~~~~~~~~~~~~~~~

For a better explanation refer to the `SciPy documentation <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html>`_, :cite:t:`scipy` .

.. math:: f(x, a, b)=\frac{\Gamma(a+b) x^{a-1}(1-x)^{b-1}}{\Gamma(a) \Gamma(b)}
   :label: beta

Given :math:`0<=x<=1, a>0, b>0` , :math:`\Gamma` is the gamma function.

Example code on the usage of the Beta class::

    from gemact import distributions
    import numpy as np

    a=2
    b=5
    dist=distributions.Beta(a=a,
                            b=b)

    seq=np.arange(0,1,.001)
    nsim=int(1e+05)

    print('Theorical mean',dist.mean())
    print('Theorical variance',dist.var())
    #compare with simulations
    print('Simulated mean',np.mean(dist.rvs(nsim)))
    print('Simulated variance',np.var(dist.rvs(nsim)))
Then, use ``matplotlib`` library to print the pmf and the cdf of a Beta::

    import matplotlib.pyplot as plt

    #pmf
    plt.hist(dist.rvs(nsim),
             bins=100,
             density=True)
    plt.title('Probability density function, ~Beta(a=2,b=5)')
    #cdf
    plt.plot(seq,dist.cdf(seq))
    plt.title('Cumulative distribution function,  ~Beta(a=2,b=5)')

.. image:: images/pdfBeta.png
  :width: 400

.. image:: images/cdfBeta.png
  :width: 400




References
=================
.. bibliography::



